# 05 - ステータス管理機能

> [[04-データベース設計]] | [[spotMe設計書]] | Next: [[06-API設計]]

## ⭐ コア機能：詳細ステータス管理

**spotMe の最大の差別化要素**である詳細ステータス管理機能の設計詳細。従来の「◯時に◯◯で」という曖昧な待ち合わせを、**8段階の詳細ステータス**でリアルタイム管理。

---

## 🎯 ステータス種類定義

### プリセットステータス（8種類）

| ステータス | キー | アイコン | 説明 | 位置情報 | 使用場面 |
|------------|------|----------|------|----------|----------|
| **未出発** | `NOT_STARTED` | 🏠 | まだ家にいる | 不要 | 準備中、まだ時間がある |
| **家を出た** | `HOME_DEPARTED` | 🚶 | 家を出発した | 任意 | 移動開始のお知らせ |
| **駅到着** | `STATION_ARRIVED` | 🚉 | 最寄り駅に到着 | 任意 | 電車待ち、乗車予定 |
| **電車乗車中** | `ON_TRAIN` | 🚃 | 電車に乗っている | 任意 | 移動中、到着予定時刻共有 |
| **乗り換え中** | `TRANSFERRING` | 🔄 | 乗り換え駅にいる | 任意 | 遅延リスク、次の電車待ち |
| **到着間近** | `NEAR_ARRIVAL` | ⏱️ | もうすぐ到着 | 任意 | ラスト5-10分、準備完了 |
| **到着済み** | `ARRIVED` | ✅ | 集合場所に到着 | 自動ON | 他メンバーを待機中 |
| **遅延中** | `DELAYED` | ⚠️ | 遅れている | 任意 | トラブル発生、新しい到着予定 |

### カスタムステータス

| ステータス | キー | アイコン | 説明 |
|------------|------|----------|------|
| **カスタム** | `CUSTOM` | 💬 | 自由入力（最大200文字） |

**カスタムメッセージ例**:
- 「電車が5分遅れてます😭」
- 「コンビニ寄ってから向かいます」
- 「雨で少し遅くなりそうです」
- 「先に席確保してます🍺」

---

## 🔄 ステータス更新フロー

### システムフロー図

```
[ユーザー操作]
    │
    ├── 📱 プリセットステータス選択
    │   └──> タップで即座に更新
    │
    └── 💬 カスタムステータス選択
        └──> モーダル表示
             ├── メッセージ入力（最大200文字）
             ├── 位置情報共有設定
             └── 到着予定時刻設定
    │
    ↓
[FastAPI サーバー処理]
    │
    ├── 🔐 JWT 認証検証
    ├── 📝 データバリデーション
    ├── 🗄️ PostgreSQL 永続化
    └── ⚡ Firestore リアルタイム同期
    │
    ↓
[他ユーザーへの配信]
    │
    ├── 📱 Firestore Listener → UI 更新
    ├── 🔔 重要ステータス → プッシュ通知
    └── 💬 ステータス変更 → チャット投稿
```

### 詳細更新ロジック

```python
async def update_user_status(
    event_id: UUID,
    user_id: UUID,
    status_data: StatusUpdateRequest
):
    """ユーザーステータス更新のメイン処理"""

    # 1. バリデーション
    validate_status_update(status_data)

    # 2. PostgreSQL に永続化
    db_status = await save_status_to_postgres(
        event_id, user_id, status_data
    )

    # 3. 到着予定時刻の自動計算
    if status_data.status_type in ['ON_TRAIN', 'TRANSFERRING']:
        estimated_time = await calculate_arrival_time(
            event_id, user_id, status_data
        )
        db_status.estimated_arrival_time = estimated_time

    # 4. Firestore にリアルタイム同期
    await sync_status_to_firestore(event_id, user_id, db_status)

    # 5. プッシュ通知（重要なステータスのみ）
    if status_data.status_type in ['ARRIVED', 'DELAYED']:
        await send_status_notification(event_id, user_id, db_status)

    return db_status
```

---

## ⚡ リアルタイム同期戦略

### データフロー設計

#### 1. 永続化層（PostgreSQL）
- **役割**: 重要データの確実な保存
- **更新頻度**: ステータス変更時
- **保持期間**: 永続化（1年後アーカイブ）

#### 2. リアルタイム層（Firestore）
- **役割**: 即座の配信とオフライン対応
- **更新頻度**: 即時同期
- **保持期間**: イベント終了後24時間

#### 3. 同期タイミング

| 操作 | PostgreSQL | Firestore | 遅延時間 |
|------|------------|-----------|----------|
| ステータス変更 | 即時 | 即時 | < 100ms |
| 位置情報更新 | 30秒間隔 | 即時 | < 200ms |
| カスタムメッセージ | 即時 | 即時 | < 100ms |
| 到着予定時刻 | 即時 | 即時 | < 100ms |

### 競合制御

```python
async def handle_concurrent_updates(event_id: UUID, user_id: UUID):
    """同時更新の競合制御"""

    # 楽観的ロック（updated_at による制御）
    current_status = await get_current_status(event_id, user_id)

    if status_data.last_updated < current_status.updated_at:
        raise ConflictError("Status was updated by another request")

    # 最新の updated_at で更新
    status_data.updated_at = datetime.utcnow()
    return await update_status(status_data)
```

---

## 📍 位置情報プライバシー制御

### 位置情報共有ルール

| イベント状況 | 位置情報共有 | ステータス表示 | 制御方法 |
|------------|------------|--------------|----------|
| **開始2時間前まで** | OFF | 「未出発」のみ | 時間ベース自動制御 |
| **開始2時間前〜終了** | ユーザー選択可 | 詳細ステータス表示 | ユーザー任意設定 |
| **「到着済み」選択時** | 自動ON（高精度） | 正確な位置表示 | システム自動制御 |
| **終了5時間後** | 強制OFF | 表示終了 | 自動削除処理 |

### 位置情報精度レベル

```python
class LocationPrecision(Enum):
    OFF = "OFF"           # 位置情報なし
    LOW = "LOW"           # 区レベル（半径500m）
    MEDIUM = "MEDIUM"     # 駅レベル（半径100m）
    HIGH = "HIGH"         # GPS正確位置（±10m）

class LocationPrivacy:
    @staticmethod
    def adjust_precision(lat: float, lng: float, precision: LocationPrecision):
        """精度レベルに応じて位置情報を調整"""
        if precision == LocationPrecision.OFF:
            return None, None
        elif precision == LocationPrecision.LOW:
            # 区レベルに丸める（約500m精度）
            return round(lat, 2), round(lng, 2)
        elif precision == LocationPrecision.MEDIUM:
            # 駅レベルに丸める（約100m精度）
            return round(lat, 3), round(lng, 3)
        else:  # HIGH
            # GPS正確な位置
            return lat, lng
```

### 自動プライバシー制御

```python
async def auto_privacy_control():
    """位置情報の自動プライバシー制御"""

    current_time = datetime.utcnow()

    # イベント終了5時間後の位置情報自動削除
    expired_events = await get_events_expired_5hours()
    for event in expired_events:
        await delete_location_data(event.id)
        await log_privacy_action(event.id, "AUTO_DELETE_LOCATION")

    # イベント開始2時間前の位置情報自動OFF
    upcoming_events = await get_events_starting_2hours()
    for event in upcoming_events:
        await disable_location_sharing(event.id)
        await log_privacy_action(event.id, "AUTO_DISABLE_LOCATION")
```

---

## 🎨 UI/UX インタラクション設計

### ステータス選択UI

```
┌─────────────────────────────────────┐
│  現在の状況を共有 📍               │
│                                     │
│  ┌───┐ ┌───┐ ┌───┐ ┌───┐       │
│  │🏠 │ │🚶│ │🚉│ │🚃│       │
│  │未 │ │家 │ │駅 │ │電 │       │
│  │出 │ │を │ │到 │ │車 │       │
│  │発 │ │出 │ │着 │ │中 │       │
│  └───┘ └───┘ └───┘ └───┘       │
│                                     │
│  ┌───┐ ┌───┐ ┌───┐ ┌───┐       │
│  │🔄│ │⏱️│ │✅│ │⚠️│       │
│  │乗 │ │到 │ │到 │ │遅 │       │
│  │換 │ │着 │ │着 │ │延 │       │
│  │中 │ │間 │ │済 │ │中 │       │
│  └───┘ └───┘ └───┘ └───┘       │
│                                     │
│  ┌─────────────────────────────┐   │
│  │ 💬 カスタムメッセージ        │   │
│  └─────────────────────────────┘   │
└─────────────────────────────────────┘
```

### メンバーステータス表示

```
┌─────────────────────────────────────┐
│  メンバーの状況 👥                 │
│                                     │
│  ┌─────────────────────────────┐   │
│  │ 👤 山田太郎               │   │
│  │ 🚃 電車乗車中              │   │
│  │ 📍 予定通り 15:30到着予定   │   │
│  │ 🕐 2分前更新               │   │
│  └─────────────────────────────┘   │
│                                     │
│  ┌─────────────────────────────┐   │
│  │ 👤 佐藤花子               │   │
│  │ 🔄 乗り換え中              │   │
│  │ ⚠️ 5分遅れ予定             │   │
│  │ 💬 「ちょっと混んでます」    │   │
│  │ 🕐 1分前更新               │   │
│  └─────────────────────────────┘   │
│                                     │
│  ┌─────────────────────────────┐   │
│  │ 👤 田中次郎               │   │
│  │ ✅ 到着済み                │   │
│  │ 📍 集合場所にいます         │   │
│  │ 💬 「先に席確保してます🍺」  │   │
│  │ 🕐 5分前更新               │   │
│  └─────────────────────────────┘   │
└─────────────────────────────────────┘
```

### インタラクション仕様

| 操作 | アクション | フィードバック |
|------|------------|--------------|
| **ステータスタップ** | 即座に更新 | ハプティック + アニメーション |
| **カスタムボタン** | モーダル表示 | スライドアップアニメーション |
| **長押し** | 詳細情報表示 | ツールチップ表示 |
| **プルリフレッシュ** | 最新情報取得 | インジケーター表示 |
| **位置情報トグル** | プライバシー設定 | 確認ダイアログ |

---

## 🚨 到着予定時刻自動計算

### 計算ロジック

```python
class ArrivalTimeCalculator:
    """到着予定時刻の自動計算"""

    async def calculate_estimated_arrival(
        self,
        event_id: UUID,
        user_id: UUID,
        current_status: str,
        location: Optional[Tuple[float, float]]
    ) -> Optional[datetime]:

        event = await get_event(event_id)

        if current_status == "ON_TRAIN" and location:
            # Google Directions API で経路計算
            route = await self.get_route_to_destination(
                origin=location,
                destination=(event.latitude, event.longitude),
                mode="transit"
            )

            # 現在時刻 + 移動時間
            return datetime.utcnow() + timedelta(
                seconds=route.duration_seconds
            )

        elif current_status == "NEAR_ARRIVAL":
            # 到着間近は5分後に設定
            return datetime.utcnow() + timedelta(minutes=5)

        elif current_status == "ARRIVED":
            # 到着済みは現在時刻
            return datetime.utcnow()

        return None
```

### 遅延検知アルゴリズム

```python
class DelayDetection:
    """遅延の自動検知"""

    async def detect_delay(self, event_id: UUID, user_id: UUID):
        """ユーザーの遅延を自動検知"""

        status = await get_current_status(event_id, user_id)
        event = await get_event(event_id)

        # イベント開始時刻を10分過ぎても未到着
        if (datetime.utcnow() > event.event_datetime + timedelta(minutes=10)
            and status.status_type != "ARRIVED"):

            # 自動的に遅延状態に更新
            await self.auto_update_to_delayed(event_id, user_id)

            # 他メンバーに通知
            await send_delay_notification(event_id, user_id)
```

---

## 🔔 プッシュ通知戦略

### 通知トリガー

| ステータス変更 | 通知タイミング | 通知内容 |
|-------------|-------------|----------|
| **ARRIVED** | 即時 | 「◯◯さんが到着しました」 |
| **DELAYED** | 即時 | 「◯◯さんが遅れています」 |
| **CUSTOM（遅延系）** | 即時 | カスタムメッセージ表示 |
| **HOME_DEPARTED** | 30分前なら通知 | 「◯◯さんが出発しました」 |

### 通知の抑制ルール

```python
class NotificationThrottling:
    """通知スパム防止"""

    async def should_send_notification(
        self,
        event_id: UUID,
        user_id: UUID,
        status_type: str
    ) -> bool:

        # 同じユーザーの通知は5分間隔で制限
        last_notification = await get_last_notification(event_id, user_id)
        if last_notification and \
           datetime.utcnow() - last_notification.sent_at < timedelta(minutes=5):
            return False

        # 重要なステータスは常に通知
        if status_type in ["ARRIVED", "DELAYED"]:
            return True

        # その他は設定に従う
        user_settings = await get_notification_settings(user_id)
        return user_settings.status_updates_enabled
```

---

## 📊 ステータス分析・メトリクス

### 収集メトリクス

| メトリクス | 目的 | 活用方法 |
|------------|------|----------|
| **ステータス更新頻度** | UX改善 | UI配置の最適化 |
| **到着予測精度** | アルゴリズム改善 | 機械学習モデル訓練 |
| **位置情報共有率** | プライバシー設計 | デフォルト設定の調整 |
| **遅延発生パターン** | ユーザー体験向上 | 事前アラート機能 |

### 分析クエリ例

```sql
-- ステータス更新頻度分析
SELECT
    status_type,
    COUNT(*) as update_count,
    AVG(EXTRACT(EPOCH FROM (updated_at - created_at))) as avg_duration
FROM user_statuses
WHERE created_at >= NOW() - INTERVAL '30 days'
GROUP BY status_type
ORDER BY update_count DESC;

-- 到着予測精度分析
SELECT
    event_id,
    AVG(EXTRACT(EPOCH FROM (
        actual_arrival - estimated_arrival_time
    ))) as prediction_error_seconds
FROM user_statuses
WHERE status_type = 'ARRIVED'
  AND estimated_arrival_time IS NOT NULL
GROUP BY event_id;
```

---

**Next**: [[06-API設計]] - RESTful API エンドポイント仕様とリクエスト/レスポンス設計