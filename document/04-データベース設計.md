# 04 - データベース設計

> [[03-技術スタック]] | [[spotMe設計書]] | Next: [[05-ステータス管理機能]]

## 🗄️ ハイブリッドデータベース構成

### 設計思想
**PostgreSQL（Cloud SQL）** と **Firestore** のハイブリッド構成により、それぞれの強みを活かした最適なデータ管理を実現。

| データベース | 用途 | 特徴 |
|-------------|------|------|
| **PostgreSQL** | 永続化・重要データ | ACID準拠・複雑クエリ・整合性 |
| **Firestore** | リアルタイム同期 | NoSQL・高速配信・オフライン対応 |

---

## 📊 ER図（PostgreSQL）

```
Users ──────< GroupMembers >────── Groups
  │                                   │
  │                                   │
  └───< Events >──────────────────────┘
        │
        ├───< EventParticipants
        │
        ├───< UserStatuses (詳細ステータス) ⭐
        │
        └───< Messages
```

---

## 🐘 PostgreSQL テーブル設計

### users（ユーザー管理）

| カラム名 | データ型 | 制約 | 説明 |
|----------|----------|------|------|
| **id** | UUID | PRIMARY KEY | ユーザーID |
| **phone_number** | VARCHAR(20) | UNIQUE, NOT NULL | 電話番号（認証用） |
| **name** | VARCHAR(100) | NOT NULL | ユーザー名 |
| **profile_image** | VARCHAR(255) | NULL | プロフィール画像URL |
| **created_at** | TIMESTAMP | NOT NULL | 作成日時 |
| **last_active_at** | TIMESTAMP | NULL | 最終アクティブ日時 |

**インデックス**:
```sql
CREATE UNIQUE INDEX idx_users_phone ON users(phone_number);
CREATE INDEX idx_users_last_active ON users(last_active_at);
```

---

### groups（グループ管理）

| カラム名 | データ型 | 制約 | 説明 |
|----------|----------|------|------|
| **id** | UUID | PRIMARY KEY | グループID |
| **name** | VARCHAR(100) | NOT NULL | グループ名 |
| **created_by** | UUID | FK(users.id) | 作成者 |
| **invite_code** | VARCHAR(10) | UNIQUE | 招待コード |
| **max_members** | INTEGER | DEFAULT 10 | 最大メンバー数 |
| **created_at** | TIMESTAMP | NOT NULL | 作成日時 |

**インデックス**:
```sql
CREATE UNIQUE INDEX idx_groups_invite_code ON groups(invite_code);
CREATE INDEX idx_groups_created_by ON groups(created_by);
```

---

### group_members（グループメンバー）

| カラム名 | データ型 | 制約 | 説明 |
|----------|----------|------|------|
| **id** | UUID | PRIMARY KEY | レコードID |
| **group_id** | UUID | FK(groups.id) | グループID |
| **user_id** | UUID | FK(users.id) | ユーザーID |
| **role** | VARCHAR(20) | DEFAULT 'member' | 権限（admin/member） |
| **joined_at** | TIMESTAMP | NOT NULL | 参加日時 |

**複合ユニーク制約**:
```sql
ALTER TABLE group_members ADD CONSTRAINT uk_group_user UNIQUE (group_id, user_id);
```

---

### events（イベント管理）

| カラム名 | データ型 | 制約 | 説明 |
|----------|----------|------|------|
| **id** | UUID | PRIMARY KEY | イベントID |
| **group_id** | UUID | FK(groups.id) | グループID |
| **title** | VARCHAR(200) | NOT NULL | イベント名 |
| **event_datetime** | TIMESTAMP | NOT NULL | 開催日時 |
| **location_name** | VARCHAR(200) | NOT NULL | 場所名 |
| **location_address** | TEXT | NULL | 住所 |
| **latitude** | DECIMAL(10,8) | NULL | 緯度 |
| **longitude** | DECIMAL(11,8) | NULL | 経度 |
| **created_by** | UUID | FK(users.id) | 作成者 |
| **created_at** | TIMESTAMP | NOT NULL | 作成日時 |

**インデックス**:
```sql
CREATE INDEX idx_events_group_id ON events(group_id);
CREATE INDEX idx_events_datetime ON events(event_datetime);
CREATE INDEX idx_events_location ON events(latitude, longitude);
```

---

### event_participants（出欠管理）

| カラム名 | データ型 | 制約 | 説明 |
|----------|----------|------|------|
| **id** | UUID | PRIMARY KEY | レコードID |
| **event_id** | UUID | FK(events.id) | イベントID |
| **user_id** | UUID | FK(users.id) | ユーザーID |
| **status** | VARCHAR(20) | NOT NULL | 出欠（attending/absent/maybe） |
| **updated_at** | TIMESTAMP | NOT NULL | 更新日時 |

**複合ユニーク制約**:
```sql
ALTER TABLE event_participants ADD CONSTRAINT uk_event_user UNIQUE (event_id, user_id);
```

---

### user_statuses（詳細ステータス） ⭐ コア機能

| カラム名 | データ型 | 制約 | 説明 |
|----------|----------|------|------|
| **id** | UUID | PRIMARY KEY | ステータスID |
| **event_id** | UUID | FK(events.id) | イベントID |
| **user_id** | UUID | FK(users.id) | ユーザーID |
| **status_type** | VARCHAR(50) | NOT NULL | ステータス種類 |
| **custom_message** | TEXT | NULL | カスタムメッセージ |
| **estimated_arrival_time** | TIMESTAMP | NULL | 到着予定時刻 |
| **is_on_schedule** | BOOLEAN | DEFAULT TRUE | 予定通りか |
| **latitude** | VARCHAR(100) | NULL | 現在地緯度（暗号化） |
| **longitude** | VARCHAR(100) | NULL | 現在地経度（暗号化） |
| **location_precision** | VARCHAR(20) | DEFAULT 'OFF' | 位置精度（OFF/LOW/MEDIUM/HIGH） |
| **updated_at** | TIMESTAMP | NOT NULL | 更新日時 |
| **created_at** | TIMESTAMP | NOT NULL | 作成日時 |

**ステータス種類（status_type）**:
- `NOT_STARTED` - 未出発 🏠
- `HOME_DEPARTED` - 家を出た 🚶
- `STATION_ARRIVED` - 駅到着 🚉
- `ON_TRAIN` - 電車乗車中 🚃
- `TRANSFERRING` - 乗り換え中 🔄
- `NEAR_ARRIVAL` - 到着間近 ⏱️
- `ARRIVED` - 到着済み ✅
- `DELAYED` - 遅延中 ⚠️
- `CUSTOM` - カスタム 💬

**インデックス**:
```sql
CREATE UNIQUE INDEX idx_user_statuses_event_user ON user_statuses(event_id, user_id);
CREATE INDEX idx_user_statuses_updated ON user_statuses(updated_at);
CREATE INDEX idx_user_statuses_event ON user_statuses(event_id);
```

---

### messages（チャットメッセージ）

| カラム名 | データ型 | 制約 | 説明 |
|----------|----------|------|------|
| **id** | UUID | PRIMARY KEY | メッセージID |
| **event_id** | UUID | FK(events.id) | イベントID |
| **user_id** | UUID | FK(users.id) | 送信者ID |
| **content** | TEXT | NOT NULL | メッセージ内容 |
| **message_type** | VARCHAR(20) | DEFAULT 'text' | メッセージ種類 |
| **created_at** | TIMESTAMP | NOT NULL | 送信日時 |

**インデックス**:
```sql
CREATE INDEX idx_messages_event_created ON messages(event_id, created_at);
```

---

## 🔥 Firestore コレクション設計

### リアルタイムステータス

```
events/{eventId}/
├── statuses/{userId}
│   ├── status_type: string
│   ├── custom_message: string?
│   ├── user_name: string
│   ├── user_id: string
│   ├── estimated_arrival_time: timestamp?
│   ├── is_on_schedule: boolean
│   ├── location_precision: string
│   └── updated_at: timestamp
│
└── messages/{messageId}
    ├── user_id: string
    ├── user_name: string
    ├── content: string
    ├── type: "text" | "status" | "system"
    └── created_at: timestamp
```

### セキュリティルール

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // イベント参加者のみアクセス可能
    match /events/{eventId}/{document=**} {
      allow read, write: if isEventParticipant(eventId);
    }

    // 自分のステータスのみ更新可能
    match /events/{eventId}/statuses/{userId} {
      allow write: if request.auth.uid == userId && isEventParticipant(eventId);
    }
  }

  function isEventParticipant(eventId) {
    return request.auth != null &&
           request.auth.uid in resource.data.participants;
  }
}
```

---

## 🔄 データ同期戦略

### PostgreSQL → Firestore 同期

```python
# ステータス更新時の同期処理
async def update_user_status(event_id: UUID, user_id: UUID, status_data: dict):
    # 1. PostgreSQL に永続化
    await update_status_in_postgres(event_id, user_id, status_data)

    # 2. Firestore にリアルタイム同期
    await sync_to_firestore(event_id, user_id, status_data)

    # 3. プッシュ通知（重要なステータス変更時）
    if status_data['status_type'] in ['ARRIVED', 'DELAYED']:
        await send_push_notification(event_id, status_data)
```

### 同期タイミング

| 操作 | PostgreSQL | Firestore | 同期遅延 |
|------|------------|-----------|----------|
| ステータス更新 | 即時 | 即時 | < 100ms |
| 位置情報更新 | 30秒間隔 | 即時 | < 200ms |
| チャットメッセージ | 即時 | 即時 | < 100ms |

---

## 🔐 データ暗号化

### 位置情報の暗号化

```python
import cryptography.fernet as fernet

class LocationEncryption:
    def __init__(self, key: str):
        self.cipher = fernet.Fernet(key.encode())

    def encrypt_coordinates(self, lat: float, lng: float) -> tuple:
        """位置情報をAES暗号化"""
        encrypted_lat = self.cipher.encrypt(str(lat).encode())
        encrypted_lng = self.cipher.encrypt(str(lng).encode())
        return encrypted_lat.decode(), encrypted_lng.decode()

    def decrypt_coordinates(self, encrypted_lat: str, encrypted_lng: str) -> tuple:
        """暗号化された位置情報を復号化"""
        lat = float(self.cipher.decrypt(encrypted_lat.encode()).decode())
        lng = float(self.cipher.decrypt(encrypted_lng.encode()).decode())
        return lat, lng
```

### プライバシー制御レベル

| 精度レベル | 表示範囲 | 用途 |
|------------|----------|------|
| **OFF** | 非表示 | プライバシー重視 |
| **LOW** | 区レベル（半径500m） | 大まかな位置 |
| **MEDIUM** | 駅レベル（半径100m） | 交通機関利用時 |
| **HIGH** | GPS正確位置（±10m） | 到着確認時 |

---

## 📈 パフォーマンス最適化

### インデックス戦略

```sql
-- 複合インデックス（頻繁なクエリ用）
CREATE INDEX idx_events_group_datetime ON events(group_id, event_datetime);
CREATE INDEX idx_statuses_event_updated ON user_statuses(event_id, updated_at);

-- 部分インデックス（条件付きクエリ用）
CREATE INDEX idx_active_events ON events(event_datetime)
  WHERE event_datetime > now() - interval '1 day';

-- GIN インデックス（全文検索用）
CREATE INDEX idx_messages_content_gin ON messages USING gin(to_tsvector('japanese', content));
```

### クエリ最適化

```python
# 悪い例：N+1クエリ
for event in events:
    statuses = await get_statuses_by_event(event.id)  # ❌

# 良い例：バッチクエリ
event_ids = [event.id for event in events]
all_statuses = await get_statuses_by_events(event_ids)  # ✅
```

---

## 🗑️ データ保持ポリシー

### 自動削除スケジュール

| データ種類 | 保持期間 | 削除方法 |
|------------|----------|----------|
| **チャットメッセージ** | 30日 | Cloud Functions |
| **位置情報** | イベント終了後24時間 | 自動暗号化削除 |
| **古いステータス** | 7日 | バッチ処理 |
| **イベント履歴** | 1年 | アーカイブ後削除 |

### GDPR 対応

```python
async def delete_user_data(user_id: UUID):
    """GDPR Right to be Forgotten 対応"""
    # 1. 個人識別情報の匿名化
    await anonymize_user_messages(user_id)

    # 2. 位置情報の完全削除
    await delete_location_data(user_id)

    # 3. プロフィール情報の削除
    await delete_user_profile(user_id)

    # 4. 削除ログの記録
    await log_deletion_request(user_id)
```

---

## 🔍 監視・メトリクス

### データベース監視指標

| 指標 | 閾値 | アラート |
|------|------|----------|
| 接続数 | > 80% | Slack通知 |
| CPU使用率 | > 80% | 自動スケール |
| ディスク使用率 | > 90% | 緊急対応 |
| スロークエリ | > 1秒 | 分析要求 |

### Firestore 監視指標

| 指標 | 閾値 | 最適化 |
|------|------|--------|
| 読み取り数/秒 | > 10,000 | インデックス見直し |
| 書き込み数/秒 | > 1,000 | バッチ処理 |
| ホットスポット | 検出時 | シャーディング |

---

**Next**: [[05-ステータス管理機能]] - コア機能の詳細設計とリアルタイム同期