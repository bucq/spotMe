# 09 - セキュリティとプライバシー

> [[08-品質保証とテスト]] | [[BondPoint設計書]] | Next: [[10-監視と運用]]

## 🔐 セキュリティ設計

### セキュリティフレームワーク
**Defense in Depth（多層防御）** による包括的なセキュリティ対策

```
🛡️ アプリケーション層
├─ JWT 認証・認可
├─ 入力値検証・サニタイズ
├─ HTTPS 通信強制
└─ セッション管理

🔥 ネットワーク層
├─ Cloud Armor（DDoS対策）
├─ Load Balancer（SSL終端）
├─ VPC（内部通信）
└─ Firewall Rules

🏗️ インフラ層
├─ IAM（最小権限）
├─ Secret Manager
├─ 暗号化（保存時・転送時）
└─ 監査ログ
```

---

## 🔑 認証・認可システム

### JWT 認証フロー

```
[ユーザー]
    │
    ├── 1. 電話番号 + SMS認証
    │   └──> POST /api/v1/auth/register
    │
    ├── 2. 認証コード検証
    │   └──> POST /api/v1/auth/verify
    │        └──> JWT発行（RS256）
    │
    └── 3. 以降のAPIリクエスト
        └──> Authorization: Bearer {access_token}
             └──> JWT検証 → ユーザー識別
```

### JWT トークン仕様

#### Access Token
```json
{
  "iss": "bondpoint.com",
  "sub": "123e4567-e89b-12d3-a456-426614174000",
  "aud": "bondpoint-mobile",
  "exp": 1640995200,
  "iat": 1640991600,
  "nbf": 1640991600,
  "jti": "unique-token-id",
  "user_id": "123e4567-e89b-12d3-a456-426614174000",
  "phone_number": "+81-90-1234-5678",
  "roles": ["user"]
}
```

#### Refresh Token
```json
{
  "iss": "bondpoint.com",
  "sub": "123e4567-e89b-12d3-a456-426614174000",
  "exp": 1643587200,
  "token_type": "refresh"
}
```

### トークン管理

```python
import jwt
from datetime import datetime, timedelta
from cryptography.hazmat.primitives import serialization

class JWTManager:
    def __init__(self, private_key: str, public_key: str):
        self.private_key = serialization.load_pem_private_key(
            private_key.encode(), password=None
        )
        self.public_key = serialization.load_pem_public_key(
            public_key.encode()
        )

    def create_access_token(self, user_id: str, phone_number: str) -> str:
        """アクセストークン生成（有効期限1時間）"""
        payload = {
            "iss": "bondpoint.com",
            "sub": user_id,
            "aud": "bondpoint-mobile",
            "exp": datetime.utcnow() + timedelta(hours=1),
            "iat": datetime.utcnow(),
            "user_id": user_id,
            "phone_number": phone_number,
            "roles": ["user"]
        }
        return jwt.encode(payload, self.private_key, algorithm="RS256")

    def verify_token(self, token: str) -> dict:
        """トークン検証・デコード"""
        try:
            payload = jwt.decode(
                token,
                self.public_key,
                algorithms=["RS256"],
                audience="bondpoint-mobile",
                issuer="bondpoint.com"
            )
            return payload
        except jwt.ExpiredSignatureError:
            raise AuthenticationError("Token has expired")
        except jwt.InvalidTokenError:
            raise AuthenticationError("Invalid token")
```

---

## 🏛️ 認可システム

### ロールベースアクセス制御（RBAC）

| ロール | 権限 | 説明 |
|--------|------|------|
| **user** | 基本ユーザー権限 | グループ参加、イベント参加、ステータス更新 |
| **group_admin** | グループ管理権限 | メンバー招待・削除、イベント作成・削除 |
| **system_admin** | システム管理権限 | 全データアクセス、システム設定 |

### リソース別アクセス制御

```python
from enum import Enum
from functools import wraps

class Permission(Enum):
    READ = "read"
    WRITE = "write"
    DELETE = "delete"
    ADMIN = "admin"

class AccessControl:
    """リソース別アクセス制御"""

    @staticmethod
    def check_group_access(user_id: str, group_id: str, permission: Permission) -> bool:
        """グループアクセス権限チェック"""
        membership = get_group_membership(user_id, group_id)

        if not membership:
            return False

        if permission == Permission.READ:
            return True
        elif permission == Permission.WRITE:
            return True  # メンバーは書き込み可能
        elif permission == Permission.DELETE:
            return membership.role == "admin"
        elif permission == Permission.ADMIN:
            return membership.role == "admin"

        return False

    @staticmethod
    def check_event_access(user_id: str, event_id: str, permission: Permission) -> bool:
        """イベントアクセス権限チェック"""
        participation = get_event_participation(user_id, event_id)

        if not participation:
            return False

        if permission == Permission.READ:
            return True
        elif permission == Permission.WRITE:
            # 参加者は自分のステータスのみ更新可能
            return True
        elif permission == Permission.DELETE:
            event = get_event(event_id)
            return event.created_by == user_id

        return False

def require_permission(resource_type: str, permission: Permission):
    """デコレーター：API エンドポイント認可"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # リクエストからユーザーIDとリソースIDを取得
            user_id = get_current_user_id()
            resource_id = kwargs.get(f"{resource_type}_id")

            # アクセス権限チェック
            if resource_type == "group":
                has_access = AccessControl.check_group_access(
                    user_id, resource_id, permission
                )
            elif resource_type == "event":
                has_access = AccessControl.check_event_access(
                    user_id, resource_id, permission
                )
            else:
                has_access = False

            if not has_access:
                raise ForbiddenError("Access denied")

            return await func(*args, **kwargs)
        return wrapper
    return decorator

# 使用例
@app.post("/api/v1/events/{event_id}/status")
@require_permission("event", Permission.WRITE)
async def update_status(event_id: str, status_data: StatusUpdate):
    # 認可済みのユーザーのみここに到達
    return await update_user_status(event_id, status_data)
```

---

## 🔒 データ保護

### 個人情報分類

| データ分類 | 例 | 保護レベル | 暗号化 |
|------------|---|-----------|---------|
| **機密（L3）** | 位置情報、電話番号 | AES-256 | 必須 |
| **制限（L2）** | プロフィール情報、メッセージ | TLS | 転送時 |
| **内部（L1）** | イベント名、公開情報 | TLS | 転送時のみ |

### 位置情報の暗号化保護

```python
import os
from cryptography.fernet import Fernet
from typing import Optional, Tuple

class LocationEncryption:
    """位置情報専用暗号化クラス"""

    def __init__(self):
        # Cloud Secret Manager から暗号化キーを取得
        self.encryption_key = os.getenv("LOCATION_ENCRYPTION_KEY")
        self.cipher = Fernet(self.encryption_key.encode())

    def encrypt_coordinates(self, lat: float, lng: float, precision: str) -> Tuple[str, str]:
        """位置情報の暗号化"""
        # 精度レベルに応じた座標調整
        adjusted_lat, adjusted_lng = self._adjust_precision(lat, lng, precision)

        # AES暗号化
        encrypted_lat = self.cipher.encrypt(str(adjusted_lat).encode()).decode()
        encrypted_lng = self.cipher.encrypt(str(adjusted_lng).encode()).decode()

        return encrypted_lat, encrypted_lng

    def decrypt_coordinates(self, encrypted_lat: str, encrypted_lng: str) -> Tuple[float, float]:
        """位置情報の復号化"""
        try:
            lat = float(self.cipher.decrypt(encrypted_lat.encode()).decode())
            lng = float(self.cipher.decrypt(encrypted_lng.encode()).decode())
            return lat, lng
        except Exception:
            raise DecryptionError("Failed to decrypt coordinates")

    def _adjust_precision(self, lat: float, lng: float, precision: str) -> Tuple[float, float]:
        """精度レベルに応じた位置情報調整"""
        if precision == "OFF":
            return None, None
        elif precision == "LOW":
            # 区レベル（500m精度）
            return round(lat, 2), round(lng, 2)
        elif precision == "MEDIUM":
            # 駅レベル（100m精度）
            return round(lat, 3), round(lng, 3)
        else:  # HIGH
            return lat, lng
```

### データベース暗号化

#### 保存時暗号化（Cloud SQL）
```sql
-- 暗号化対象カラムの設定
ALTER TABLE user_statuses
ADD COLUMN encrypted_latitude BYTEA,
ADD COLUMN encrypted_longitude BYTEA;

-- 暗号化関数の例
CREATE OR REPLACE FUNCTION encrypt_location(
    plaintext TEXT,
    key_name TEXT
) RETURNS BYTEA AS $$
BEGIN
    -- Cloud KMS を使用した暗号化
    RETURN pgp_sym_encrypt(plaintext, key_name);
END;
$$ LANGUAGE plpgsql;
```

---

## 🛡️ プライバシー設計

### プライバシー by Design 原則

1. **Proactive not Reactive**: 事前にプライバシー保護を組み込み
2. **Privacy as the Default**: デフォルトで最大限のプライバシー保護
3. **Full Functionality**: 機能性を損なわない設計
4. **End-to-End Security**: 全体を通じたセキュリティ
5. **Visibility and Transparency**: 透明性の確保
6. **Respect for User Privacy**: ユーザープライバシーの尊重

### 位置情報プライバシー制御

#### プライバシー設定レベル

```python
from enum import Enum
from datetime import datetime, timedelta

class PrivacyLevel(Enum):
    OFF = "off"           # 位置情報共有なし
    EVENT_ONLY = "event"  # イベント期間中のみ
    FRIENDS = "friends"   # 友人のみ
    CUSTOM = "custom"     # カスタム設定

class LocationPrivacyManager:
    """位置情報プライバシー管理"""

    @staticmethod
    def should_share_location(
        user_id: str,
        event_id: str,
        current_time: datetime
    ) -> bool:
        """位置情報共有可否の判定"""

        # ユーザーの基本設定取得
        privacy_settings = get_user_privacy_settings(user_id)

        # OFF設定の場合は無条件で拒否
        if privacy_settings.location_sharing == PrivacyLevel.OFF:
            return False

        # イベント固有の設定取得
        event = get_event(event_id)
        event_settings = get_event_privacy_settings(user_id, event_id)

        # イベント期間中のみ共有
        if privacy_settings.location_sharing == PrivacyLevel.EVENT_ONLY:
            event_start = event.event_datetime - timedelta(hours=2)
            event_end = event.event_datetime + timedelta(hours=5)

            if not (event_start <= current_time <= event_end):
                return False

        # 到着済みの場合は自動的に高精度で共有
        current_status = get_current_user_status(user_id, event_id)
        if current_status and current_status.status_type == "ARRIVED":
            return True

        # その他の場合はユーザー設定に従う
        return event_settings.location_enabled if event_settings else False

    @staticmethod
    def get_location_precision(user_id: str, event_id: str) -> str:
        """位置情報精度レベルの取得"""
        settings = get_event_privacy_settings(user_id, event_id)
        current_status = get_current_user_status(user_id, event_id)

        # 到着済みの場合は高精度
        if current_status and current_status.status_type == "ARRIVED":
            return "HIGH"

        # ユーザー設定または低精度
        return settings.precision_level if settings else "LOW"
```

### データ最小化

#### 自動データ削除

```python
import asyncio
from datetime import datetime, timedelta

class DataMinimization:
    """データ最小化・自動削除"""

    @staticmethod
    async def cleanup_expired_data():
        """期限切れデータの自動削除"""
        current_time = datetime.utcnow()

        # 1. 位置情報の削除（イベント終了5時間後）
        expired_events = await get_events_older_than(
            current_time - timedelta(hours=5)
        )

        for event in expired_events:
            await delete_location_data(event.id)
            await log_data_deletion("location", event.id, "auto_cleanup")

        # 2. チャットメッセージの削除（30日後）
        old_messages = await get_messages_older_than(
            current_time - timedelta(days=30)
        )

        for message in old_messages:
            await delete_message(message.id)
            await log_data_deletion("message", message.id, "retention_policy")

        # 3. 未使用ステータスの削除（7日後）
        old_statuses = await get_unused_statuses_older_than(
            current_time - timedelta(days=7)
        )

        for status in old_statuses:
            await delete_user_status(status.id)
            await log_data_deletion("status", status.id, "unused_cleanup")

    @staticmethod
    async def anonymize_user_data(user_id: str):
        """GDPR Right to be Forgotten 対応"""

        # 1. 個人識別情報の匿名化
        await anonymize_user_profile(user_id)

        # 2. メッセージの匿名化（履歴保持のため）
        await anonymize_user_messages(user_id)

        # 3. 位置情報の完全削除
        await delete_all_location_data(user_id)

        # 4. 削除ログの記録
        await log_data_deletion("user_account", user_id, "gdpr_request")

        # 5. 関連セッションの無効化
        await invalidate_all_user_sessions(user_id)
```

---

## 🔍 セキュリティ監査

### 監査ログ

#### 監査対象イベント

| カテゴリ | イベント | ログレベル | 保持期間 |
|---------|----------|------------|----------|
| **認証** | ログイン成功/失敗 | INFO/WARN | 1年 |
| **認可** | 権限チェック失敗 | WARN | 6ヶ月 |
| **データアクセス** | 機密データアクセス | INFO | 3ヶ月 |
| **設定変更** | プライバシー設定変更 | INFO | 1年 |
| **データ削除** | 個人情報削除 | CRITICAL | 永続 |

#### 監査ログ形式

```json
{
  "timestamp": "2025-09-29T15:30:00Z",
  "event_type": "authentication",
  "action": "login_success",
  "user_id": "123e4567-e89b-12d3-a456-426614174000",
  "ip_address": "203.0.113.1",
  "user_agent": "BondPoint/1.0 (iOS 17.1)",
  "resource": "/api/v1/auth/login",
  "result": "success",
  "metadata": {
    "phone_number_hash": "sha256:a1b2c3...",
    "session_id": "sess_abc123",
    "geolocation": "JP"
  }
}
```

### 脆弱性対策

#### OWASP Top 10 対策

| 脆弱性 | 対策 | 実装例 |
|--------|------|--------|
| **A01: Broken Access Control** | RBAC実装 | `@require_permission` デコレーター |
| **A02: Cryptographic Failures** | 強力な暗号化 | AES-256, RS256 JWT |
| **A03: Injection** | パラメータ化クエリ | SQLAlchemy ORM |
| **A04: Insecure Design** | セキュリティ設計 | プライバシー by Design |
| **A05: Security Misconfiguration** | 設定強化 | Cloud Security Command Center |
| **A06: Vulnerable Components** | 依存関係管理 | Dependabot, Snyk |
| **A07: Authentication Failures** | 多要素認証 | SMS認証 |
| **A08: Software Integrity** | コード署名 | GitHub Actions署名 |
| **A09: Logging Failures** | 包括的ログ | 構造化ログ |
| **A10: SSRF** | 入力検証 | URL検証、許可リスト |

### セキュリティテスト

#### 自動セキュリティスキャン

```yaml
# .github/workflows/security.yml
name: Security Scan

on: [push, pull_request]

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Run Bandit Security Scan
      run: |
        pip install bandit
        bandit -r app/ -f json -o security-report.json

    - name: Run Safety Check
      run: |
        pip install safety
        safety check --json --output safety-report.json

    - name: Run Semgrep
      run: |
        docker run --rm -v "${PWD}:/src" returntocorp/semgrep \
          --config=auto --json --output=semgrep-report.json /src

    - name: Upload Security Reports
      uses: actions/upload-artifact@v3
      with:
        name: security-reports
        path: "*-report.json"
```

---

## 📋 コンプライアンス

### GDPR 対応

#### データ処理の合法的根拠

| データ種類 | 合法的根拠 | 説明 |
|------------|-----------|------|
| **アカウント情報** | 契約履行 | サービス提供に必要 |
| **位置情報** | 同意 | 明示的な同意取得 |
| **利用統計** | 正当な利益 | サービス改善目的 |
| **支払い情報** | 契約履行 | 決済処理に必要 |

#### GDPR 権利対応

```python
class GDPRCompliance:
    """GDPR権利対応"""

    @staticmethod
    async def handle_data_portability(user_id: str) -> dict:
        """データポータビリティ権（Article 20）"""
        user_data = {
            "personal_info": await get_user_profile(user_id),
            "groups": await get_user_groups(user_id),
            "events": await get_user_events(user_id),
            "messages": await get_user_messages(user_id),
            "settings": await get_user_settings(user_id)
        }

        # 機械読み取り可能な形式で提供
        return {
            "format": "JSON",
            "encoding": "UTF-8",
            "data": user_data,
            "exported_at": datetime.utcnow().isoformat()
        }

    @staticmethod
    async def handle_rectification(user_id: str, corrections: dict):
        """訂正権（Article 16）"""
        # バリデーション
        validated_data = validate_personal_data(corrections)

        # データ更新
        await update_user_profile(user_id, validated_data)

        # 監査ログ
        await log_data_change("rectification", user_id, corrections)

    @staticmethod
    async def handle_erasure(user_id: str, reason: str):
        """消去権（Article 17）"""
        # 消去可能性チェック
        if not can_erase_user_data(user_id):
            raise DataErasureError("Cannot erase due to legal obligations")

        # 段階的データ削除
        await anonymize_user_data(user_id)
        await delete_user_account(user_id)

        # 監査ログ（永続保存）
        await log_data_deletion("gdpr_erasure", user_id, reason)
```

### 個人情報保護法対応

#### 同意管理

```python
class ConsentManager:
    """同意管理システム"""

    @staticmethod
    async def record_consent(
        user_id: str,
        purpose: str,
        consent_given: bool,
        consent_method: str = "app_interface"
    ):
        """同意の記録"""
        consent_record = {
            "user_id": user_id,
            "purpose": purpose,
            "consent_given": consent_given,
            "consent_method": consent_method,
            "timestamp": datetime.utcnow(),
            "ip_address": get_client_ip(),
            "user_agent": get_user_agent()
        }

        await save_consent_record(consent_record)

    @staticmethod
    async def check_consent(user_id: str, purpose: str) -> bool:
        """同意状況の確認"""
        latest_consent = await get_latest_consent(user_id, purpose)

        if not latest_consent:
            return False

        # 同意の有効性チェック
        if latest_consent.expires_at and latest_consent.expires_at < datetime.utcnow():
            return False

        return latest_consent.consent_given

    @staticmethod
    async def withdraw_consent(user_id: str, purpose: str):
        """同意の撤回"""
        await record_consent(user_id, purpose, False, "withdrawal")

        # 関連データの処理停止
        if purpose == "location_sharing":
            await disable_location_sharing(user_id)
        elif purpose == "marketing":
            await unsubscribe_marketing(user_id)
```

---

**Next**: [[10-監視と運用]] - システム監視・運用・保守の設計