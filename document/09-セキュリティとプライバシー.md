# 09 - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼

> [[08-å“è³ªä¿è¨¼ã¨ãƒ†ã‚¹ãƒˆ]] | [[BondPointè¨­è¨ˆæ›¸]] | Next: [[10-ç›£è¦–ã¨é‹ç”¨]]

## ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
**Defense in Depthï¼ˆå¤šå±¤é˜²å¾¡ï¼‰** ã«ã‚ˆã‚‹åŒ…æ‹¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–

```
ğŸ›¡ï¸ ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤
â”œâ”€ JWT èªè¨¼ãƒ»èªå¯
â”œâ”€ å…¥åŠ›å€¤æ¤œè¨¼ãƒ»ã‚µãƒ‹ã‚¿ã‚¤ã‚º
â”œâ”€ HTTPS é€šä¿¡å¼·åˆ¶
â””â”€ ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†

ğŸ”¥ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å±¤
â”œâ”€ Cloud Armorï¼ˆDDoSå¯¾ç­–ï¼‰
â”œâ”€ Load Balancerï¼ˆSSLçµ‚ç«¯ï¼‰
â”œâ”€ VPCï¼ˆå†…éƒ¨é€šä¿¡ï¼‰
â””â”€ Firewall Rules

ğŸ—ï¸ ã‚¤ãƒ³ãƒ•ãƒ©å±¤
â”œâ”€ IAMï¼ˆæœ€å°æ¨©é™ï¼‰
â”œâ”€ Secret Manager
â”œâ”€ æš—å·åŒ–ï¼ˆä¿å­˜æ™‚ãƒ»è»¢é€æ™‚ï¼‰
â””â”€ ç›£æŸ»ãƒ­ã‚°
```

---

## ğŸ”‘ èªè¨¼ãƒ»èªå¯ã‚·ã‚¹ãƒ†ãƒ 

### JWT èªè¨¼ãƒ•ãƒ­ãƒ¼

```
[ãƒ¦ãƒ¼ã‚¶ãƒ¼]
    â”‚
    â”œâ”€â”€ 1. é›»è©±ç•ªå· + SMSèªè¨¼
    â”‚   â””â”€â”€> POST /api/v1/auth/register
    â”‚
    â”œâ”€â”€ 2. èªè¨¼ã‚³ãƒ¼ãƒ‰æ¤œè¨¼
    â”‚   â””â”€â”€> POST /api/v1/auth/verify
    â”‚        â””â”€â”€> JWTç™ºè¡Œï¼ˆRS256ï¼‰
    â”‚
    â””â”€â”€ 3. ä»¥é™ã®APIãƒªã‚¯ã‚¨ã‚¹ãƒˆ
        â””â”€â”€> Authorization: Bearer {access_token}
             â””â”€â”€> JWTæ¤œè¨¼ â†’ ãƒ¦ãƒ¼ã‚¶ãƒ¼è­˜åˆ¥
```

### JWT ãƒˆãƒ¼ã‚¯ãƒ³ä»•æ§˜

#### Access Token
```json
{
  "iss": "bondpoint.com",
  "sub": "123e4567-e89b-12d3-a456-426614174000",
  "aud": "bondpoint-mobile",
  "exp": 1640995200,
  "iat": 1640991600,
  "nbf": 1640991600,
  "jti": "unique-token-id",
  "user_id": "123e4567-e89b-12d3-a456-426614174000",
  "phone_number": "+81-90-1234-5678",
  "roles": ["user"]
}
```

#### Refresh Token
```json
{
  "iss": "bondpoint.com",
  "sub": "123e4567-e89b-12d3-a456-426614174000",
  "exp": 1643587200,
  "token_type": "refresh"
}
```

### ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†

```python
import jwt
from datetime import datetime, timedelta
from cryptography.hazmat.primitives import serialization

class JWTManager:
    def __init__(self, private_key: str, public_key: str):
        self.private_key = serialization.load_pem_private_key(
            private_key.encode(), password=None
        )
        self.public_key = serialization.load_pem_public_key(
            public_key.encode()
        )

    def create_access_token(self, user_id: str, phone_number: str) -> str:
        """ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆï¼ˆæœ‰åŠ¹æœŸé™1æ™‚é–“ï¼‰"""
        payload = {
            "iss": "bondpoint.com",
            "sub": user_id,
            "aud": "bondpoint-mobile",
            "exp": datetime.utcnow() + timedelta(hours=1),
            "iat": datetime.utcnow(),
            "user_id": user_id,
            "phone_number": phone_number,
            "roles": ["user"]
        }
        return jwt.encode(payload, self.private_key, algorithm="RS256")

    def verify_token(self, token: str) -> dict:
        """ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼ãƒ»ãƒ‡ã‚³ãƒ¼ãƒ‰"""
        try:
            payload = jwt.decode(
                token,
                self.public_key,
                algorithms=["RS256"],
                audience="bondpoint-mobile",
                issuer="bondpoint.com"
            )
            return payload
        except jwt.ExpiredSignatureError:
            raise AuthenticationError("Token has expired")
        except jwt.InvalidTokenError:
            raise AuthenticationError("Invalid token")
```

---

## ğŸ›ï¸ èªå¯ã‚·ã‚¹ãƒ†ãƒ 

### ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ï¼ˆRBACï¼‰

| ãƒ­ãƒ¼ãƒ« | æ¨©é™ | èª¬æ˜ |
|--------|------|------|
| **user** | åŸºæœ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¨©é™ | ã‚°ãƒ«ãƒ¼ãƒ—å‚åŠ ã€ã‚¤ãƒ™ãƒ³ãƒˆå‚åŠ ã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–° |
| **group_admin** | ã‚°ãƒ«ãƒ¼ãƒ—ç®¡ç†æ¨©é™ | ãƒ¡ãƒ³ãƒãƒ¼æ‹›å¾…ãƒ»å‰Šé™¤ã€ã‚¤ãƒ™ãƒ³ãƒˆä½œæˆãƒ»å‰Šé™¤ |
| **system_admin** | ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†æ¨©é™ | å…¨ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ã€ã‚·ã‚¹ãƒ†ãƒ è¨­å®š |

### ãƒªã‚½ãƒ¼ã‚¹åˆ¥ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡

```python
from enum import Enum
from functools import wraps

class Permission(Enum):
    READ = "read"
    WRITE = "write"
    DELETE = "delete"
    ADMIN = "admin"

class AccessControl:
    """ãƒªã‚½ãƒ¼ã‚¹åˆ¥ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡"""

    @staticmethod
    def check_group_access(user_id: str, group_id: str, permission: Permission) -> bool:
        """ã‚°ãƒ«ãƒ¼ãƒ—ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãƒã‚§ãƒƒã‚¯"""
        membership = get_group_membership(user_id, group_id)

        if not membership:
            return False

        if permission == Permission.READ:
            return True
        elif permission == Permission.WRITE:
            return True  # ãƒ¡ãƒ³ãƒãƒ¼ã¯æ›¸ãè¾¼ã¿å¯èƒ½
        elif permission == Permission.DELETE:
            return membership.role == "admin"
        elif permission == Permission.ADMIN:
            return membership.role == "admin"

        return False

    @staticmethod
    def check_event_access(user_id: str, event_id: str, permission: Permission) -> bool:
        """ã‚¤ãƒ™ãƒ³ãƒˆã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãƒã‚§ãƒƒã‚¯"""
        participation = get_event_participation(user_id, event_id)

        if not participation:
            return False

        if permission == Permission.READ:
            return True
        elif permission == Permission.WRITE:
            # å‚åŠ è€…ã¯è‡ªåˆ†ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ã¿æ›´æ–°å¯èƒ½
            return True
        elif permission == Permission.DELETE:
            event = get_event(event_id)
            return event.created_by == user_id

        return False

def require_permission(resource_type: str, permission: Permission):
    """ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼šAPI ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆèªå¯"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã¨ãƒªã‚½ãƒ¼ã‚¹IDã‚’å–å¾—
            user_id = get_current_user_id()
            resource_id = kwargs.get(f"{resource_type}_id")

            # ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãƒã‚§ãƒƒã‚¯
            if resource_type == "group":
                has_access = AccessControl.check_group_access(
                    user_id, resource_id, permission
                )
            elif resource_type == "event":
                has_access = AccessControl.check_event_access(
                    user_id, resource_id, permission
                )
            else:
                has_access = False

            if not has_access:
                raise ForbiddenError("Access denied")

            return await func(*args, **kwargs)
        return wrapper
    return decorator

# ä½¿ç”¨ä¾‹
@app.post("/api/v1/events/{event_id}/status")
@require_permission("event", Permission.WRITE)
async def update_status(event_id: str, status_data: StatusUpdate):
    # èªå¯æ¸ˆã¿ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿ã“ã“ã«åˆ°é”
    return await update_user_status(event_id, status_data)
```

---

## ğŸ”’ ãƒ‡ãƒ¼ã‚¿ä¿è­·

### å€‹äººæƒ…å ±åˆ†é¡

| ãƒ‡ãƒ¼ã‚¿åˆ†é¡ | ä¾‹ | ä¿è­·ãƒ¬ãƒ™ãƒ« | æš—å·åŒ– |
|------------|---|-----------|---------|
| **æ©Ÿå¯†ï¼ˆL3ï¼‰** | ä½ç½®æƒ…å ±ã€é›»è©±ç•ªå· | AES-256 | å¿…é ˆ |
| **åˆ¶é™ï¼ˆL2ï¼‰** | ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ | TLS | è»¢é€æ™‚ |
| **å†…éƒ¨ï¼ˆL1ï¼‰** | ã‚¤ãƒ™ãƒ³ãƒˆåã€å…¬é–‹æƒ…å ± | TLS | è»¢é€æ™‚ã®ã¿ |

### ä½ç½®æƒ…å ±ã®æš—å·åŒ–ä¿è­·

```python
import os
from cryptography.fernet import Fernet
from typing import Optional, Tuple

class LocationEncryption:
    """ä½ç½®æƒ…å ±å°‚ç”¨æš—å·åŒ–ã‚¯ãƒ©ã‚¹"""

    def __init__(self):
        # Cloud Secret Manager ã‹ã‚‰æš—å·åŒ–ã‚­ãƒ¼ã‚’å–å¾—
        self.encryption_key = os.getenv("LOCATION_ENCRYPTION_KEY")
        self.cipher = Fernet(self.encryption_key.encode())

    def encrypt_coordinates(self, lat: float, lng: float, precision: str) -> Tuple[str, str]:
        """ä½ç½®æƒ…å ±ã®æš—å·åŒ–"""
        # ç²¾åº¦ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸåº§æ¨™èª¿æ•´
        adjusted_lat, adjusted_lng = self._adjust_precision(lat, lng, precision)

        # AESæš—å·åŒ–
        encrypted_lat = self.cipher.encrypt(str(adjusted_lat).encode()).decode()
        encrypted_lng = self.cipher.encrypt(str(adjusted_lng).encode()).decode()

        return encrypted_lat, encrypted_lng

    def decrypt_coordinates(self, encrypted_lat: str, encrypted_lng: str) -> Tuple[float, float]:
        """ä½ç½®æƒ…å ±ã®å¾©å·åŒ–"""
        try:
            lat = float(self.cipher.decrypt(encrypted_lat.encode()).decode())
            lng = float(self.cipher.decrypt(encrypted_lng.encode()).decode())
            return lat, lng
        except Exception:
            raise DecryptionError("Failed to decrypt coordinates")

    def _adjust_precision(self, lat: float, lng: float, precision: str) -> Tuple[float, float]:
        """ç²¾åº¦ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸä½ç½®æƒ…å ±èª¿æ•´"""
        if precision == "OFF":
            return None, None
        elif precision == "LOW":
            # åŒºãƒ¬ãƒ™ãƒ«ï¼ˆ500mç²¾åº¦ï¼‰
            return round(lat, 2), round(lng, 2)
        elif precision == "MEDIUM":
            # é§…ãƒ¬ãƒ™ãƒ«ï¼ˆ100mç²¾åº¦ï¼‰
            return round(lat, 3), round(lng, 3)
        else:  # HIGH
            return lat, lng
```

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æš—å·åŒ–

#### ä¿å­˜æ™‚æš—å·åŒ–ï¼ˆCloud SQLï¼‰
```sql
-- æš—å·åŒ–å¯¾è±¡ã‚«ãƒ©ãƒ ã®è¨­å®š
ALTER TABLE user_statuses
ADD COLUMN encrypted_latitude BYTEA,
ADD COLUMN encrypted_longitude BYTEA;

-- æš—å·åŒ–é–¢æ•°ã®ä¾‹
CREATE OR REPLACE FUNCTION encrypt_location(
    plaintext TEXT,
    key_name TEXT
) RETURNS BYTEA AS $$
BEGIN
    -- Cloud KMS ã‚’ä½¿ç”¨ã—ãŸæš—å·åŒ–
    RETURN pgp_sym_encrypt(plaintext, key_name);
END;
$$ LANGUAGE plpgsql;
```

---

## ğŸ›¡ï¸ ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼è¨­è¨ˆ

### ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ by Design åŸå‰‡

1. **Proactive not Reactive**: äº‹å‰ã«ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·ã‚’çµ„ã¿è¾¼ã¿
2. **Privacy as the Default**: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æœ€å¤§é™ã®ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·
3. **Full Functionality**: æ©Ÿèƒ½æ€§ã‚’æãªã‚ãªã„è¨­è¨ˆ
4. **End-to-End Security**: å…¨ä½“ã‚’é€šã˜ãŸã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
5. **Visibility and Transparency**: é€æ˜æ€§ã®ç¢ºä¿
6. **Respect for User Privacy**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã®å°Šé‡

### ä½ç½®æƒ…å ±ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼åˆ¶å¾¡

#### ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼è¨­å®šãƒ¬ãƒ™ãƒ«

```python
from enum import Enum
from datetime import datetime, timedelta

class PrivacyLevel(Enum):
    OFF = "off"           # ä½ç½®æƒ…å ±å…±æœ‰ãªã—
    EVENT_ONLY = "event"  # ã‚¤ãƒ™ãƒ³ãƒˆæœŸé–“ä¸­ã®ã¿
    FRIENDS = "friends"   # å‹äººã®ã¿
    CUSTOM = "custom"     # ã‚«ã‚¹ã‚¿ãƒ è¨­å®š

class LocationPrivacyManager:
    """ä½ç½®æƒ…å ±ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ç®¡ç†"""

    @staticmethod
    def should_share_location(
        user_id: str,
        event_id: str,
        current_time: datetime
    ) -> bool:
        """ä½ç½®æƒ…å ±å…±æœ‰å¯å¦ã®åˆ¤å®š"""

        # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®åŸºæœ¬è¨­å®šå–å¾—
        privacy_settings = get_user_privacy_settings(user_id)

        # OFFè¨­å®šã®å ´åˆã¯ç„¡æ¡ä»¶ã§æ‹’å¦
        if privacy_settings.location_sharing == PrivacyLevel.OFF:
            return False

        # ã‚¤ãƒ™ãƒ³ãƒˆå›ºæœ‰ã®è¨­å®šå–å¾—
        event = get_event(event_id)
        event_settings = get_event_privacy_settings(user_id, event_id)

        # ã‚¤ãƒ™ãƒ³ãƒˆæœŸé–“ä¸­ã®ã¿å…±æœ‰
        if privacy_settings.location_sharing == PrivacyLevel.EVENT_ONLY:
            event_start = event.event_datetime - timedelta(hours=2)
            event_end = event.event_datetime + timedelta(hours=5)

            if not (event_start <= current_time <= event_end):
                return False

        # åˆ°ç€æ¸ˆã¿ã®å ´åˆã¯è‡ªå‹•çš„ã«é«˜ç²¾åº¦ã§å…±æœ‰
        current_status = get_current_user_status(user_id, event_id)
        if current_status and current_status.status_type == "ARRIVED":
            return True

        # ãã®ä»–ã®å ´åˆã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã«å¾“ã†
        return event_settings.location_enabled if event_settings else False

    @staticmethod
    def get_location_precision(user_id: str, event_id: str) -> str:
        """ä½ç½®æƒ…å ±ç²¾åº¦ãƒ¬ãƒ™ãƒ«ã®å–å¾—"""
        settings = get_event_privacy_settings(user_id, event_id)
        current_status = get_current_user_status(user_id, event_id)

        # åˆ°ç€æ¸ˆã¿ã®å ´åˆã¯é«˜ç²¾åº¦
        if current_status and current_status.status_type == "ARRIVED":
            return "HIGH"

        # ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã¾ãŸã¯ä½ç²¾åº¦
        return settings.precision_level if settings else "LOW"
```

### ãƒ‡ãƒ¼ã‚¿æœ€å°åŒ–

#### è‡ªå‹•ãƒ‡ãƒ¼ã‚¿å‰Šé™¤

```python
import asyncio
from datetime import datetime, timedelta

class DataMinimization:
    """ãƒ‡ãƒ¼ã‚¿æœ€å°åŒ–ãƒ»è‡ªå‹•å‰Šé™¤"""

    @staticmethod
    async def cleanup_expired_data():
        """æœŸé™åˆ‡ã‚Œãƒ‡ãƒ¼ã‚¿ã®è‡ªå‹•å‰Šé™¤"""
        current_time = datetime.utcnow()

        # 1. ä½ç½®æƒ…å ±ã®å‰Šé™¤ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆçµ‚äº†5æ™‚é–“å¾Œï¼‰
        expired_events = await get_events_older_than(
            current_time - timedelta(hours=5)
        )

        for event in expired_events:
            await delete_location_data(event.id)
            await log_data_deletion("location", event.id, "auto_cleanup")

        # 2. ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‰Šé™¤ï¼ˆ30æ—¥å¾Œï¼‰
        old_messages = await get_messages_older_than(
            current_time - timedelta(days=30)
        )

        for message in old_messages:
            await delete_message(message.id)
            await log_data_deletion("message", message.id, "retention_policy")

        # 3. æœªä½¿ç”¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®å‰Šé™¤ï¼ˆ7æ—¥å¾Œï¼‰
        old_statuses = await get_unused_statuses_older_than(
            current_time - timedelta(days=7)
        )

        for status in old_statuses:
            await delete_user_status(status.id)
            await log_data_deletion("status", status.id, "unused_cleanup")

    @staticmethod
    async def anonymize_user_data(user_id: str):
        """GDPR Right to be Forgotten å¯¾å¿œ"""

        # 1. å€‹äººè­˜åˆ¥æƒ…å ±ã®åŒ¿ååŒ–
        await anonymize_user_profile(user_id)

        # 2. ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®åŒ¿ååŒ–ï¼ˆå±¥æ­´ä¿æŒã®ãŸã‚ï¼‰
        await anonymize_user_messages(user_id)

        # 3. ä½ç½®æƒ…å ±ã®å®Œå…¨å‰Šé™¤
        await delete_all_location_data(user_id)

        # 4. å‰Šé™¤ãƒ­ã‚°ã®è¨˜éŒ²
        await log_data_deletion("user_account", user_id, "gdpr_request")

        # 5. é–¢é€£ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ç„¡åŠ¹åŒ–
        await invalidate_all_user_sessions(user_id)
```

---

## ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»

### ç›£æŸ»ãƒ­ã‚°

#### ç›£æŸ»å¯¾è±¡ã‚¤ãƒ™ãƒ³ãƒˆ

| ã‚«ãƒ†ã‚´ãƒª | ã‚¤ãƒ™ãƒ³ãƒˆ | ãƒ­ã‚°ãƒ¬ãƒ™ãƒ« | ä¿æŒæœŸé–“ |
|---------|----------|------------|----------|
| **èªè¨¼** | ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ/å¤±æ•— | INFO/WARN | 1å¹´ |
| **èªå¯** | æ¨©é™ãƒã‚§ãƒƒã‚¯å¤±æ•— | WARN | 6ãƒ¶æœˆ |
| **ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹** | æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ | INFO | 3ãƒ¶æœˆ |
| **è¨­å®šå¤‰æ›´** | ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼è¨­å®šå¤‰æ›´ | INFO | 1å¹´ |
| **ãƒ‡ãƒ¼ã‚¿å‰Šé™¤** | å€‹äººæƒ…å ±å‰Šé™¤ | CRITICAL | æ°¸ç¶š |

#### ç›£æŸ»ãƒ­ã‚°å½¢å¼

```json
{
  "timestamp": "2025-09-29T15:30:00Z",
  "event_type": "authentication",
  "action": "login_success",
  "user_id": "123e4567-e89b-12d3-a456-426614174000",
  "ip_address": "203.0.113.1",
  "user_agent": "BondPoint/1.0 (iOS 17.1)",
  "resource": "/api/v1/auth/login",
  "result": "success",
  "metadata": {
    "phone_number_hash": "sha256:a1b2c3...",
    "session_id": "sess_abc123",
    "geolocation": "JP"
  }
}
```

### è„†å¼±æ€§å¯¾ç­–

#### OWASP Top 10 å¯¾ç­–

| è„†å¼±æ€§ | å¯¾ç­– | å®Ÿè£…ä¾‹ |
|--------|------|--------|
| **A01: Broken Access Control** | RBACå®Ÿè£… | `@require_permission` ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ |
| **A02: Cryptographic Failures** | å¼·åŠ›ãªæš—å·åŒ– | AES-256, RS256 JWT |
| **A03: Injection** | ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚¯ã‚¨ãƒª | SQLAlchemy ORM |
| **A04: Insecure Design** | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ | ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ by Design |
| **A05: Security Misconfiguration** | è¨­å®šå¼·åŒ– | Cloud Security Command Center |
| **A06: Vulnerable Components** | ä¾å­˜é–¢ä¿‚ç®¡ç† | Dependabot, Snyk |
| **A07: Authentication Failures** | å¤šè¦ç´ èªè¨¼ | SMSèªè¨¼ |
| **A08: Software Integrity** | ã‚³ãƒ¼ãƒ‰ç½²å | GitHub Actionsç½²å |
| **A09: Logging Failures** | åŒ…æ‹¬çš„ãƒ­ã‚° | æ§‹é€ åŒ–ãƒ­ã‚° |
| **A10: SSRF** | å…¥åŠ›æ¤œè¨¼ | URLæ¤œè¨¼ã€è¨±å¯ãƒªã‚¹ãƒˆ |

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ

#### è‡ªå‹•ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³

```yaml
# .github/workflows/security.yml
name: Security Scan

on: [push, pull_request]

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Run Bandit Security Scan
      run: |
        pip install bandit
        bandit -r app/ -f json -o security-report.json

    - name: Run Safety Check
      run: |
        pip install safety
        safety check --json --output safety-report.json

    - name: Run Semgrep
      run: |
        docker run --rm -v "${PWD}:/src" returntocorp/semgrep \
          --config=auto --json --output=semgrep-report.json /src

    - name: Upload Security Reports
      uses: actions/upload-artifact@v3
      with:
        name: security-reports
        path: "*-report.json"
```

---

## ğŸ“‹ ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹

### GDPR å¯¾å¿œ

#### ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã®åˆæ³•çš„æ ¹æ‹ 

| ãƒ‡ãƒ¼ã‚¿ç¨®é¡ | åˆæ³•çš„æ ¹æ‹  | èª¬æ˜ |
|------------|-----------|------|
| **ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±** | å¥‘ç´„å±¥è¡Œ | ã‚µãƒ¼ãƒ“ã‚¹æä¾›ã«å¿…è¦ |
| **ä½ç½®æƒ…å ±** | åŒæ„ | æ˜ç¤ºçš„ãªåŒæ„å–å¾— |
| **åˆ©ç”¨çµ±è¨ˆ** | æ­£å½“ãªåˆ©ç›Š | ã‚µãƒ¼ãƒ“ã‚¹æ”¹å–„ç›®çš„ |
| **æ”¯æ‰•ã„æƒ…å ±** | å¥‘ç´„å±¥è¡Œ | æ±ºæ¸ˆå‡¦ç†ã«å¿…è¦ |

#### GDPR æ¨©åˆ©å¯¾å¿œ

```python
class GDPRCompliance:
    """GDPRæ¨©åˆ©å¯¾å¿œ"""

    @staticmethod
    async def handle_data_portability(user_id: str) -> dict:
        """ãƒ‡ãƒ¼ã‚¿ãƒãƒ¼ã‚¿ãƒ“ãƒªãƒ†ã‚£æ¨©ï¼ˆArticle 20ï¼‰"""
        user_data = {
            "personal_info": await get_user_profile(user_id),
            "groups": await get_user_groups(user_id),
            "events": await get_user_events(user_id),
            "messages": await get_user_messages(user_id),
            "settings": await get_user_settings(user_id)
        }

        # æ©Ÿæ¢°èª­ã¿å–ã‚Šå¯èƒ½ãªå½¢å¼ã§æä¾›
        return {
            "format": "JSON",
            "encoding": "UTF-8",
            "data": user_data,
            "exported_at": datetime.utcnow().isoformat()
        }

    @staticmethod
    async def handle_rectification(user_id: str, corrections: dict):
        """è¨‚æ­£æ¨©ï¼ˆArticle 16ï¼‰"""
        # ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        validated_data = validate_personal_data(corrections)

        # ãƒ‡ãƒ¼ã‚¿æ›´æ–°
        await update_user_profile(user_id, validated_data)

        # ç›£æŸ»ãƒ­ã‚°
        await log_data_change("rectification", user_id, corrections)

    @staticmethod
    async def handle_erasure(user_id: str, reason: str):
        """æ¶ˆå»æ¨©ï¼ˆArticle 17ï¼‰"""
        # æ¶ˆå»å¯èƒ½æ€§ãƒã‚§ãƒƒã‚¯
        if not can_erase_user_data(user_id):
            raise DataErasureError("Cannot erase due to legal obligations")

        # æ®µéšçš„ãƒ‡ãƒ¼ã‚¿å‰Šé™¤
        await anonymize_user_data(user_id)
        await delete_user_account(user_id)

        # ç›£æŸ»ãƒ­ã‚°ï¼ˆæ°¸ç¶šä¿å­˜ï¼‰
        await log_data_deletion("gdpr_erasure", user_id, reason)
```

### å€‹äººæƒ…å ±ä¿è­·æ³•å¯¾å¿œ

#### åŒæ„ç®¡ç†

```python
class ConsentManager:
    """åŒæ„ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ """

    @staticmethod
    async def record_consent(
        user_id: str,
        purpose: str,
        consent_given: bool,
        consent_method: str = "app_interface"
    ):
        """åŒæ„ã®è¨˜éŒ²"""
        consent_record = {
            "user_id": user_id,
            "purpose": purpose,
            "consent_given": consent_given,
            "consent_method": consent_method,
            "timestamp": datetime.utcnow(),
            "ip_address": get_client_ip(),
            "user_agent": get_user_agent()
        }

        await save_consent_record(consent_record)

    @staticmethod
    async def check_consent(user_id: str, purpose: str) -> bool:
        """åŒæ„çŠ¶æ³ã®ç¢ºèª"""
        latest_consent = await get_latest_consent(user_id, purpose)

        if not latest_consent:
            return False

        # åŒæ„ã®æœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯
        if latest_consent.expires_at and latest_consent.expires_at < datetime.utcnow():
            return False

        return latest_consent.consent_given

    @staticmethod
    async def withdraw_consent(user_id: str, purpose: str):
        """åŒæ„ã®æ’¤å›"""
        await record_consent(user_id, purpose, False, "withdrawal")

        # é–¢é€£ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†åœæ­¢
        if purpose == "location_sharing":
            await disable_location_sharing(user_id)
        elif purpose == "marketing":
            await unsubscribe_marketing(user_id)
```

---

**Next**: [[10-ç›£è¦–ã¨é‹ç”¨]] - ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ»é‹ç”¨ãƒ»ä¿å®ˆã®è¨­è¨ˆ